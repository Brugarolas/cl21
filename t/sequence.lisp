(in-package :cl21-user)
(defpackage cl21-test.sequence
  (:use :cl21
        :cl-test-more))
(in-package :cl21-test.sequence)

(plan 176)

(is (take 3 '(1 3 5 6 7 8))
    '(1 3 5)
    "take")
(is (take 3 #(1 3 5 6 7 8))
    #(1 3 5)
    :test #'equalp
    "take")
(is (take 3 "Hello, World!")
    "Hel"
    "take")

(is (drop 3 '(1 3 5 6 7 8))
    '(6 7 8)
    "drop")
(is (drop 3 #(1 3 5 6 7 8))
    #(6 7 8)
    :test #'equalp
    "drop")
(is (drop 3 "Hello, World!")
    "lo, World!"
    "drop")

(is (take-while #'oddp '(1 3 5 6 7 8))
    '(1 3 5)
    "take-while")
(is (take-while #'oddp '(0 1 3 5 6 7 8))
    '()
    "take-while")
(is (take-while #'oddp #(1 3 5 6 7 8))
    #(1 3 5)
    :test #'equalp
    "take-while")
(is (take-while #'oddp #(0 1 3 5 6 7 8))
    #()
    :test #'equalp
    "take-while")
(is (take-while (lambda (x) (not (char= x #\,))) "Hello, World!")
    "Hello"
    "take-while")
(is (take-while (lambda (x) (not (char= x #\,))) ",Hello, World!")
    ""
    "take-while")

(is (drop-while #'oddp '(1 3 5 6 7 8))
    '(6 7 8)
    "drop-while")
(is (drop-while #'oddp '(1 3 5 7))
    '()
    "drop-while")
(is (drop-while #'oddp #(1 3 5 6 7 8))
    #(6 7 8)
    :test #'equalp
    "drop-while")
(is (drop-while #'oddp #(1 3 5 7))
    #()
    :test #'equalp
    "drop-while")
(is (drop-while (lambda (x) (not (char= x #\,))) "Hello, World!")
    ", World!"
    "drop-while")
(is (drop-while (lambda (x) (not (char= x #\,))) "Hello World!")
    ""
    "drop-while")

(defclass my-list (abstract-list)
  ((elements :type cons :initarg :elements :initform nil)))
(defun make-my-list (&rest elements)
  (make-instance 'my-list :elements elements))
(defmethod abstract-first ((seq my-list))
  (car (slot-value seq 'elements)))
(defmethod abstract-rest ((seq my-list))
  (apply #'make-my-list (cdr (slot-value seq 'elements))))
(defmethod abstract-cons (obj (seq my-list))
  (apply #'make-my-list (cons obj (slot-value seq 'elements))))
(defmethod emptyp ((object my-list))
  (emptyp (slot-value object 'elements)))

(defclass my-vector (abstract-vector)
  ((elements :type vector :initarg :elements :initform (make-array 0 :adjustable t :fill-pointer 0))))
(defun make-my-vector (&rest elements)
  (make-instance 'my-vector :elements (make-array (length elements) :adjustable t :fill-pointer t
                                                                    :initial-contents elements)))
(defmethod abstract-elt ((vec my-vector) index)
  (elt (slot-value vec 'elements) index))
(defmethod abstract-subseq ((vec my-vector) start &optional end)
  (subseq (slot-value vec 'elements) start end))
(defmethod abstract-vector-pop ((vec my-vector))
  (vector-pop (slot-value vec 'elements)))
(defmethod emptyp ((object my-vector))
  (emptyp (slot-value object 'elements)))

(let ((seq (make-my-list 1 2 3)))
  (is (take 2 seq) '(1 2) "take")
  (let ((seq-rest (drop 10 seq)))
    (is-type seq-rest 'my-list "drop")
    (ok (emptyp seq-rest) "emptyp"))
  (is (subseq seq 1) '(2 3) "subseq")
  (is (subseq seq 1 2) '(2) "subseq")
  (is (last seq) 3 "last")

  (is (butlast '(1 2 3)) '(1 2) "butlast")
  (is (butlast '(1 2 3) 0) '(1 2 3) "butlast")
  (is (butlast seq) '(1 2) "butlast")
  (is (butlast seq 0) '(1 2 3) "butlast")
  (let ((head (pop seq)))
    (is head 1 "pop")
    (is (coerce seq 'list) '(2 3) "pop")))
(let ((seq (make-my-vector 1 2 3)))
  (let ((seq-rest (drop 3 seq)))
    (ok (emptyp seq-rest) "emptyp"))
  (is (last seq) 3 "last")

  (is (butlast seq) #(1 2) :test #'equalp "butlast")
  (is (butlast seq 0) #(1 2 3) :test #'equalp "butlast")
  (let ((head (pop seq)))
    (is head 3 "pop")
    (is (coerce seq 'vector) #(1 2) :test #'equalp "pop")))

(is (take-while #'minusp '(-2 -1 0 1 2 3))
    '(-2 -1)
    "take-while")
(is (take-while #'plusp '(2 1 1 1 2 3))
    '(2 1 1 1 2 3)
    "take-while")
(is (take-while #'minusp (make-my-list -2 -1 0 1 2 3))
    '(-2 -1)
    "take-while")
(is (take-while #'plusp (make-my-list 2 1 1 1 2 3))
    '(2 1 1 1 2 3)
    "take-while")
(is (drop-while #'minusp '(-1 -2 -6 -7 1 2 3 4 -5 -6 0 1))
    '(1 2 3 4 -5 -6 0 1)
    "drop-while")
(is (drop-while #'minusp '(-1 -2 -6 -7 -5 -6))
    nil
    "drop-while")
(is (drop-while #'plusp '(-1 -2 -6 -7 -5 -6))
    '(-1 -2 -6 -7 -5 -6)
    "drop-while")
(let ((dropped-seq (drop-while #'minusp (make-my-list -1 -2 -6 -7 1 2 3 4 -5 -6 0 1))))
  (is-type dropped-seq 'my-list "drop-while")
  (is (coerce dropped-seq 'list)
      '(1 2 3 4 -5 -6 0 1)
      "drop-while"))
(let ((dropped-seq (drop-while #'minusp (make-my-vector -1 -2 -6 -7 1 2 3 4 -5 -6 0 1))))
  (is (coerce dropped-seq 'list)
      '(1 2 3 4 -5 -6 0 1)
      "drop-while"))

(is (position-if (lambda (x) (zerop x)) '(-1 -2 -3 0 4)) 3 "position-if")
(is (position-if (lambda (x) (zerop x)) '(0 -1 -2 -3 0 4) :start 1)
    4
    "position-if")
(is (position-if (lambda (x) (zerop x)) '(0 -1 -2 -3 0 4) :start 1 :end 3)
    nil
    "position-if")
(is (position-if (lambda (x) (zerop x)) '(0 -1 -2 -3 0 4) :start 1 :end 5)
    4
    "position-if")
(is (position-if (lambda (x) (zerop x)) (make-my-list -1 -2 -3 0 4))
    3
    "position-if")
(is (position-if (lambda (x) (zerop x)) (make-my-list 0 -1 -2 -3 0 4) :start 1)
    4
    "position-if")
(is (position-if (lambda (x) (zerop x)) (make-my-list 0 -1 -2 -3 0 4) :start 1 :end 3)
    nil
    "position-if")
(let ((seq (make-my-vector 0 -1 -2 -3 0 4)))
  (is (position-if (lambda (x) (zerop x)) seq :start 1 :end 5)
      4
      "position-if")
  (is (coerce seq 'list)
      '(0 -1 -2 -3 0 4)
      "position-if"))
(is (position-if (lambda (x) (zerop x)) (make-my-vector -1 -2 -3 0 4))
    3
    "position-if")
(is (position-if (lambda (x) (zerop x)) (make-my-vector 0 -1 -2 -3 0 4) :start 1)
    4
    "position-if")
(is (position-if (lambda (x) (zerop x)) (make-my-vector 0 -1 -2 -3 0 4) :start 1 :end 3)
    nil
    "position-if")
(let ((seq (make-my-vector 0 -1 -2 -3 0 4)))
  (is (position-if (lambda (x) (zerop x)) seq :start 1 :end 5)
      4
      "position-if")
  (is (coerce seq 'list)
      '(0 -1 -2 -3 0 4)
      "position-if"))
(is (position 0 '(1 2 3)) nil "position")
(is (position 0 '(0 1 2 3)) 0 "position")
(is (position 0 (make-my-list 1 2 3)) nil "position")
(is (position 0 (make-my-list 0 1 2 3)) 0 "position")
(is (position 0 (make-my-vector 1 2 3)) nil "position")
(is (position 0 (make-my-vector 0 1 2 3)) 0 "position")

(is (search '(0 1) '(2 4 6 0 1 3 5)) 3 "search")
(is (search '(0 1) '(2 4 6 1 3 5)) nil "search")
(is (search "dog" "it's a dog's life") 7 "search")
(is (search '(0 1) '(2 4 6 1 3 5) :key #'oddp) 2 "search")
(is (search '(0 1) (make-my-list 2 4 6 0 1 3 5)) 3 "search")
(is (search '(0 1) (make-my-list 2 4 6 1 3 5)) nil "search")
(is (search '(0 1) (make-my-list 2 4 6 1 3 5) :key #'oddp) 2 "search")
(is (search '(0 1) (make-my-vector 2 4 6 0 1 3 5)) 3 "search")
(is (search '(0 1) (make-my-vector 2 4 6 1 3 5)) nil "search")
(is (search '(0 1) (make-my-vector 2 4 6 1 3 5) :key #'oddp) 2 "search")

(is (elt '(0 1 2 3) 2) 2 "elt")
(is (elt (make-my-list 0 1 2 3) 2) 2 "elt")
(is (elt (make-my-vector 0 1 2 3) 2) 2 "elt")

(is (remove-if (lambda (x) (zerop x))
               '(0 1 2 3 0.0 4 5))
    '(1 2 3 4 5)
    "remove-if")
(let ((seq (remove-if #'zerop
                      (make-my-list 0 1 2 3 0.0 4 5))))
  (is-type seq 'list "remove-if")
  (is seq '(1 2 3 4 5) "remove-if"))
(let ((seq (remove-if #'zerop
                      (make-my-list 1 0 2 3 0.0 4 5)
                      :count 1)))
  (is-type seq 'list "remove-if")
  (is (coerce seq 'list) '(1 2 3 0.0 4 5)
      "remove-if"))
(let ((seq (remove-if #'zerop
                      (make-my-vector 0 1 2 3 0.0 4 5))))
  (is-type seq 'vector "remove-if")
  (is seq #(1 2 3 4 5) :test #'equalp "remove-if"))
(let ((seq (remove-if #'zerop
                      (make-my-vector 1 0 2 3 0.0 4 5)
                      :count 1)))
  (is-type seq 'vector "remove-if")
  (is seq #(1 2 3 0.0 4 5) :test #'equalp
      "remove-if"))

(is (mismatch "abcd" "ABCDE" :test #'char-equal) 4 "mismatch")
(is (mismatch '(3 2 1 1 2 3) '(1 2 3) :from-end t) 3 "mismatch")
(is (mismatch '(1 2 3 4 5 6) '(3 4 5 6 7) :start1 2 :end2 4) NIL "mismatch")
(is (mismatch '(1 2 3) '(1 2 3)) nil "mismatch")
(is (mismatch '(3 2 1 1 2 3) (make-my-list 1 2 3) :from-end t) 3 "mismatch")
(is (mismatch '(1 2 3 4 5 6) (make-my-list 3 4 5 6 7) :start1 2 :end2 4) NIL "mismatch")
(is (mismatch '(1 2 3) (make-my-list 1 2 3)) nil "mismatch")
(is (mismatch '(3 2 1 1 2 3) (make-my-vector 1 2 3) :from-end t) 3 "mismatch")
(is (mismatch '(1 2 3 4 5 6) (make-my-vector 3 4 5 6 7) :start1 2 :end2 4) NIL "mismatch")
(is (mismatch '(1 2 3) (make-my-vector 1 2 3)) nil "mismatch")

(ok (length= 1 '(1)) "length=")
(ok (length= '(1 2 3) '(a b c)) "length=")
(ok (length= '(1 2 3) 3 '(a b c)) "length=")
(ok (not (length= 1 2)) "length=")
(ok (not (length= 0 '(1))) "length=")
(ok (not (length= '(1 2 3) 3 '(a b c d e))) "length=")
(ok (length= 1 (make-my-list 1)) "length=")
(ok (length= '(1 2 3) (make-my-list 'a 'b 'c)) "length=")
(ok (length= '(1 2 3) 3 (make-my-list 'a 'b 'c)) "length=")
(ok (not (length= 0 (make-my-list 1))) "length=")
(ok (not (length= (make-my-list 1 2 3) 3 '(a b c d e))) "length=")
(ok (not (length= (make-my-list 1 2 3) '(a b c d e))) "length=")
(ok (length= 1 (make-my-vector 1)) "length=")
(ok (length= '(1 2 3) (make-my-vector 'a 'b 'c)) "length=")
(ok (length= '(1 2 3) 3 (make-my-vector 'a 'b 'c)) "length=")
(ok (not (length= 0 (make-my-vector 1))) "length=")
(ok (not (length= (make-my-vector 1 2 3) 3 '(a b c d e))) "length=")
(ok (not (length= (make-my-vector 1 2 3) '(a b c d e))) "length=")

(is (map 'string #'(lambda (x y)
                     (char "01234567890ABCDEF" (mod (+ x y) 16)))
         '(1 2 3 4)
         '(10 9 8 7))
    "AAAA"
    "map")
(is (let ((seq '("lower" "UPPER" "" "123")))
      (map nil #'nstring-upcase seq)
      seq)
    '("LOWER" "UPPER" "" "123")
    "map")
(is (map 'list #'- '(1 2 3 4))
    '(-1 -2 -3 -4)
    "map")
(is (map 'string
         #'(lambda (x) (if (oddp x) #\1 #\0))
         '(1 2 3 4))
    "1010"
    "map")

(is (map 'string #'(lambda (x y)
                     (char "01234567890ABCDEF" (mod (+ x y) 16)))
         (make-my-list 1 2 3 4)
         '(10 9 8 7))
    "AAAA"
    "map")
(is (map 'list #'- (make-my-list 1 2 3 4))
    '(-1 -2 -3 -4)
    "map")
(is (map 'string
         #'(lambda (x) (if (oddp x) #\1 #\0))
         (make-my-list 1 2 3 4))
    "1010"
    "map")
(is (map 'string #'(lambda (x y)
                     (char "01234567890ABCDEF" (mod (+ x y) 16)))
         (make-my-vector 1 2 3 4)
         '(10 9 8 7))
    "AAAA"
    "map")
(is (map 'list #'- (make-my-vector 1 2 3 4))
    '(-1 -2 -3 -4)
    "map")
(is (map 'string
         #'(lambda (x) (if (oddp x) #\1 #\0))
         (make-my-vector 1 2 3 4))
    "1010"
    "map")

(is (substitute-if 0 #'evenp '((1) (2) (3) (4)) :start 2 :key #'car)
    '((1) (2) (3) 0)
    "substitute-if")
(is (substitute-if 9 #'oddp '(1 2 4 1 3 4 5))
    '(9 2 4 9 9 4 9)
    "substitute-if")
(is (substitute-if 9 #'evenp '(1 2 4 1 3 4 5) :count 1 :from-end t)
    '(1 2 4 1 3 9 5)
    "substitute-if")
(is (substitute-if 0 #'evenp (make-my-list '(1) '(2) '(3) '(4)) :start 2 :key #'car)
    '((1) (2) (3) 0)
    "substitute-if")
(is (substitute-if 9 #'oddp (make-my-list 1 2 4 1 3 4 5))
    '(9 2 4 9 9 4 9)
    "substitute-if")
(is (substitute-if 9 #'evenp (make-my-list 1 2 4 1 3 4 5) :count 1 :from-end t)
    '(1 2 4 1 3 9 5)
    "substitute-if")
(is (substitute-if 0 #'evenp (make-my-vector '(1) '(2) '(3) '(4)) :start 2 :key #'car)
    #('(1) '(2) '(3) 0)
    :test #'equalp
    "substitute-if")
(is (substitute-if 9 #'oddp (make-my-vector 1 2 4 1 3 4 5))
    #(9 2 4 9 9 4 9)
    :test #'equalp
    "substitute-if")
(is (substitute-if 9 #'evenp (make-my-vector 1 2 4 1 3 4 5) :count 1 :from-end t)
    #(1 2 4 1 3 9 5)
    :test #'equalp
    "substitute-if")
(is (substitute #\. #\SPACE "0 2 4 6") "0.2.4.6"
    "substitute")
(is (substitute 9 4 '(1 2 4 1 3 4 5)) '(1 2 9 1 3 9 5)
    "substitute")
(is (substitute 9 4 '(1 2 4 1 3 4 5) :count 1) '(1 2 9 1 3 4 5)
    "substitute")
(is (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t)
    '(1 2 4 1 3 9 5)
    "substitute")
(is (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) '(9 9 4 9 3 4 5)
    "substitute")
(is (coerce (substitute #\. #\SPACE (apply #'make-my-list (coerce "0 2 4 6" 'list))) 'string)
    "0.2.4.6"
    "substitute")
(is (substitute 9 4 (make-my-list 1 2 4 1 3 4 5)) '(1 2 9 1 3 9 5)
    "substitute")
(is (substitute 9 4 (make-my-list 1 2 4 1 3 4 5) :count 1) '(1 2 9 1 3 4 5)
    "substitute")
(is (substitute 9 4 (make-my-list 1 2 4 1 3 4 5) :count 1 :from-end t)
    '(1 2 4 1 3 9 5)
    "substitute")
(is (substitute 9 3 (make-my-list 1 2 4 1 3 4 5) :test #'>) '(9 9 4 9 3 4 5)
    "substitute")

(is (member 2 '(1 2 3)) '(2 3)
    "member")
(is (member 'e '(a b c d)) NIL
    "member")
(is (member-if #'listp '(a b nil c d)) '(NIL C D)
    "member-if")
(is (member-if #'numberp '(a #\Space 5/3 foo)) '(5/3 FOO)
    "member-if")
(is (coerce (member 2 (make-my-list 1 2 3)) 'list) '(2 3)
    "member")
(is (coerce (member 'e (make-my-list 'a 'b 'c 'd)) 'list) NIL
    "member")
(is (coerce (member-if #'listp (make-my-list 'a 'b nil 'c 'd)) 'list) '(NIL C D)
    "member-if")
(is (coerce (member-if #'numberp (make-my-list 'a #\Space 5/3 'foo)) 'list) '(5/3 FOO)
    "member-if")

(is (split-sequence 1 '(0 1 2 3 1 2 3)) '((0) (2 3) (2 3))
    "split-sequence")
(is (split-sequence 1 (make-my-list 0 1 2 3 1 2 3)) '((0) (2 3) (2 3))
    "split-sequence")
(is (multiple-value-list (split-sequence 1 (make-my-list 0 1 2 3 1 2 3) :count 1))
    '(((0)) 2)
    "split-sequence")
(is (split-sequence 1 (make-my-list 0 1 2 3 1 1 2 3) :count 5) '((0) (2 3) NIL (2 3))
    "split-sequence")
(is (multiple-value-list
     (split-sequence 1 (make-my-list 0 1 2 3 1 1 2 3)
                     :count 5
                     :remove-empty-subseqs t))
    '(((0) (2 3) (2 3)) 8)
    "split-sequence")
(is (multiple-value-list
     (split-sequence-if #'oddp (make-my-list 0 1 1 2 3 5 8 13 21)
                        :count 3
                        :remove-empty-subseqs t))
    '(((0) (2) (8)) 9)
    "split-sequence-if")


(use-package :cl21.lazy)

(defun fib-seq ()
  (labels ((rec (a b)
             (lazy-sequence (cons a (rec b (+ a b))))))
    (rec 0 1)))

(is (take 6 (fib-seq)) '(0 1 1 2 3 5)
    "take")
(is-type (drop 6 (fib-seq)) 'lazy-sequence
         "drop")
(is (take 3 (drop 6 (fib-seq))) '(8 13 21)
    "drop & take")
(is (take-while (lambda (x) (< x 500)) (fib-seq))
    '(0 1 1 2 3 5 8 13 21 34 55 89 144 233 377)
    "take-while")
(is-type (drop-while (lambda (x) (< x 500)) (fib-seq))
         'lazy-sequence
         "drop-while")
(is (take 3 (drop-while (lambda (x) (< x 500)) (fib-seq)))
    '(610 987 1597)
    "drop-while & take")
(ok (not (emptyp (fib-seq))) "emptyp")
(is (subseq (fib-seq) 10 13)
    '(55 89 144)
    "subseq")
(is (position-if (lambda (x) (> x 500)) (fib-seq))
    15
    "position-if")
(is (position-if (lambda (x) (> x 500000)) (fib-seq) :end 30)
    29
    "position-if")
(is (position-if (lambda (x) (> x 500000)) (fib-seq) :end 20)
    nil
    "position-if")
(is (find-if (lambda (x) (> x 500)) (fib-seq))
    610
    "find-if")
(is (find-if (lambda (x) (> x 500000)) (fib-seq) :end 30)
    514229
    "find-if")
(is (find-if (lambda (x) (> x 500000)) (fib-seq) :end 20)
    nil
    "find-if")

(is (multiple-value-list
     (split-sequence-if #'oddp (fib-seq) :count 3))
    '(((0) nil (2)) 5)
    "split-sequence-if")
(is (multiple-value-list
     (split-sequence-if #'oddp (fib-seq) :end 20))
    '(((0) NIL (2) NIL (8) NIL (34) NIL (144) NIL (610) NIL (2584)) 20)
    "split-sequence-if")
(is (multiple-value-list
     (split-sequence-if #'oddp (fib-seq) :count 3 :remove-empty-subseqs t))
    '(((0) (2) (8)) 9)
    "split-sequence-if")

(finalize)
